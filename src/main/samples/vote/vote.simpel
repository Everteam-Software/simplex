processConfig.inMem = false;
processConfig.address = "/api/vote";

rootUrl = "http://localhost:3434"
emailUrl = "http://localhost:3434/api/mock/email";
load("vote-lib.js");

function addLinks(vote, addr) {
  vote.appendChild(<link rel="cancel">{rootUrl + addr + "/cancel"}</link>);
  vote.appendChild(<link rel="tally">{rootUrl + addr + "/tally"}</link>);
  return vote;
}

function createBallotInfo(vote, voteUrl, email) {
  info = vote.copy();
  info.appendChild(<link rel="ballot">{rootUrl + voteUrl + "/ballot/" + email}</link>);
  return info;
}

function buildBallotUrl(processUrl, email) {
  return rootUrl + processUrl.slice(4) + "/" + email;
}

process Vote {
  receive(self) { |newvote|
    vote = addLinks(newvote, self);
    status = <status>Vote created</status>;
    reply(status);
  }

  // Sending an e-mail to all participants to let them know a vote started
  m = 0;
  while(m < vote.participants.email.length()) {
    inviteEmail = <email><to>{ vote.participants.email[m] + "@intalio.com" }</to></email>;
    inviteEmail.body = "A vote has been started on '" + vote.text + 
      "'. Please cast your vote at " + buildBallotUrl(self, vote.participants.email[m]) + ".";
    request(emailUrl, "post", inviteEmail);
    m = m + 1;
  }

  // Declaring all necessary resources
  tally = resource("/tally");
  ballot = resource("/ballot/{email}");
  close = resource("/close");
  cancel = resource("/cancel");

  // This element will hold all the ballots
  ballots = <ballots></ballots>;

  voteOpen = true;
  scope {
    receive(cancel) { |r|
      cancelResp = <vote>Vote canceled.</vote>;
      reply(cancelResp);
    }
  } onQuery(self) {
    reply(vote);
  } onQuery(tally) {
    currentTally = getCurrentTally(ballots);
    reply(currentTally);
  } onReceive(ballot) { |b, email|
    if (voteOpen == true) {
      ballots = updateBallots(ballots, b.ballot, email);
      userBallot = getUserBallot(ballots, email);
      reply(userBallot);
    } else {
      resp = <vote>Vote is closed.</vote>;
      reply(resp);
    }
  } onQuery(ballot) { |email|
    userBallot = getUserBallot(ballots, email);
    if (userBallot.length != 0) {
      reply(userBallot);
    } else {
      info = createBallotInfo(vote, self, email);
      reply(info);
    }
  } onReceive(close) {
    voteOpen = false;
    finalTally = getCurrentTally(ballots);
    reply(finalTally);
  }
}
